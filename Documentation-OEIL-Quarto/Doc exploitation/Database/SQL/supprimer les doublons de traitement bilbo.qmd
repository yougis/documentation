---
title: Supprimer les doublons généré lors d'erreur de traitements bilbo
date: today
---



Il existe plusieurs méthodes pour supprimer les doublons issu des traitements bilbo. La meilleur stratégie dépend du contexte des données, si les tables sont lourdes ou non, si les doublons sont répartis sur plusieurs zones géographiques ou non, si les doublons sont nombreux ou non, etc.

# Cas simple

Le principe est de supprimer les doublons en se basant sur la géométrie et un champ d'identifiant unique.

```sql
DELETE FROM
    basket a
        USING basket b
WHERE
    a.id < b.id
	AND ST_Equals(a.geom, b.geom);
```


ici on supprime les doublons de pollution lumineuse en se basant sur l'égalité de la géométrie et un champ d'identifiant unique.

```sql
DELETE FROM pollution_lumineuse.faits_luminance_aires_protegees_provinciales d
WHERE  EXISTS (
   SELECT FROM pollution_lumineuse.faits_luminance_aires_protegees_provinciales
   WHERE  id_split = d.id_split
   AND    ctid < d.ctid
	AND ST_Equals(geometry, d.geometry)
	and id_spatial = d.id_spatial
   );
```





# Cas sans identifiant unique

On peut aussi, sans identifiant unique commun, supprimer les doublons des géometries du modèle **bilbo** en se basant sur l'égalité de plusieurs champs et en ajout un identifiant en fonctiontion du nombre de doublons rencontré. Cela est possible en utilisant la fonction `ROW_NUMBER()` de postgresql.

Dans le cas ci dessous on fait la requete sur une table nommée `faits_TMF_acc_h3_nc_6_2015` et on ajoute un champ `rnum` qui est un identifiant unique pour chaque doublon.

la difficulté est de trouver les champs qui permettent de définir un doublon. Dans ce cas on a choisi de se baser sur l'hex_id, l'année, l'id_spatial, la classe ainsi que la géometrie évidement. La comparaison simple d'une geometrie via `ST_AsText(geometry)` devrait normalement marcher mais dans plusieurs  cas, le nombre de décimal peut varier et donc la comparaison ne marche pas. Pour corriger cela on peut  utiliser `ST_astext(geometry,5)` pour arrondir les décimales à 5 chiffres après la virgule. Cela étant, une comparaison de géometrie peut être longue dans certain cas complexe, l'idée est alors de convertir les geometrie en enveloppe  pour ne comparer que des carrés entre eux. Cela est possible en utilisant la fonction `ST_Envelope(geometry)`.


Donc on créer une table temporaire avec les doublons identifiés `duplicate_h3_nc_acc_2015_enveloppe` :

```sql
WITH cte AS (
    SELECT 
	ROW_NUMBER() OVER ( PARTITION BY hex_id, ANNEE, id_spatial, classe,   ST_NPoints(geometry), ST_astext(ST_Envelope(geometry),5)  ORDER BY hex_id ) AS rnum,
	*
           
    FROM "processing"."faits_TMF_acc_h3_nc_6_2015" where id_spatial = '0' )

--SELECT *
SELECT * INTO "processing"."duplicate_h3_nc_acc_2015_enveloppe"

FROM cte WHERE rnum > 1;
```

Ensuite on peut les supprimer en utilisant la requete suivante :

```sql

-- créez une table temporaire pour stocker les ctid des lignes à supprimer par segments
create temp table if not exists temp_delete_ctids (temp_ctid tid);

-- fonction pour supprimer les doublons en segments
do $$
declare
    total_deleted integer := 0;
    delete_count integer;
begin
    loop
        -- sélectionnez les ctid des lignes à supprimer en segments de 10000 (ajustez cette valeur si nécessaire)
        with lignes_a_conserver as (			            
			select *, ctid as temp_ctid, 
			   row_number() over (partition by id, libelle, classe, id_spatial, annee, st_npoints(geometry), st_astext(st_envelope(geometry), 5) order by id) as row_num
			from  processing."faits_TMF_acc_h3_nc_6_APP"
			where (annee = '2015'
			or annee = '2016')
        )
        insert into temp_delete_ctids
        select temp_ctid
        from lignes_a_conserver
        where row_num > 1
        limit 74000;
        raise notice 'insert in temp table contents';
		
        -- quittez la boucle si aucun enregistrement n'a été trouvé pour suppression
        if not found then
            exit;
        end if;

        -- supprimez les enregistrements par segments de la table temporaire
        delete from "processing"."faits_TMF_acc_h3_nc_6_APP"
        where ctid in (select temp_ctid from temp_delete_ctids);
		

        -- comptez le nombre de lignes supprimées
        get diagnostics delete_count = row_count;
        raise notice 'delete_count rows: %', delete_count;
		
        -- ajoutez au total des lignes supprimées
        total_deleted := total_deleted + delete_count;

        -- réinitialisez la table temporaire pour le prochain segment
        truncate table temp_delete_ctids;
    end loop;

    raise notice 'total deleted rows: %', total_deleted;

    -- supprimez la table temporaire après l'opération
    drop table if exists temp_delete_ctids;
end $$;


```


des messages log sont affichés pour suivre l'avancement de la suppression des doublons. La suppression se fait par segment de 74000 lignes pour éviter les problèmes de mémoire. On peut ajuster cette valeur si nécessaire.

```sql
NOTICE:  insert in temp table contents
NOTICE:  delete_count rows: 74000
NOTICE:  insert in temp table contents
NOTICE:  delete_count rows: 74000
NOTICE:  insert in temp table contents
NOTICE:  delete_count rows: 74000
NOTICE:  insert in temp table contents
```


les données seront supprimer par segment de 74000 lignes. On peut ajuster cette valeur si nécessaire. toutefois si le traitment n'est pas totalement terminé les données ne seront pas supprimé et il faudra relancer le traitement.